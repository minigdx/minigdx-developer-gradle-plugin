/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.minigdx.gradle.plugin

import com.github.minigdx.gradle.plugin.internal.MiniGdxException
import com.github.minigdx.gradle.plugin.internal.MiniGdxException.Companion.ISSUES
import com.github.minigdx.gradle.plugin.internal.Severity
import com.github.minigdx.gradle.plugin.internal.Solution
import org.danilopianini.gradle.mavencentral.PublishOnCentralExtension
import org.danilopianini.gradle.mavencentral.portal.PublishPortalDeployment.Companion.RELEASE_TASK_NAME
import org.danilopianini.gradle.mavencentral.tasks.ZipMavenCentralPortalPublication
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.plugins.signing.Sign
import org.gradle.plugins.signing.SigningExtension
import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.plugin.extraProperties
import java.io.File

/**
 * Plugin for developers of MiniGDX project.
 *
 * It configures plugins used in the project that are commons to all projects
 * like the publication, kotlin version, ...
 */
class MiniGdxDeveloperPlugin : Plugin<Project> {

    private val classLoader = MiniGdxDeveloperPlugin::class.java.classLoader

    override fun apply(project: Project) {
        project.extensions.create("minigdxDeveloper", MiniGdxDeveloperExtension::class.java, project)
        configureGradleVersion(project)
        configureProjectVersionAndGroupId(project)
        configureProjectRepository(project)
        configureDokka(project)
        configurePublication(project)
        configureLinter(project)
        configureMakefile(project)
        configureGithubWorkflow(project)

        configureSonatype(project)
    }

    private fun configureGradleVersion(project: Project) {
        val projectName = project.name
        val gradleVersion = project.gradle.gradleVersion

        if (GradleVersion.current() < GradleVersion.version("6.8.2")) {
            throw MiniGdxException.create(
                severity = Severity.EASY,
                projectName = projectName,
                gradleVersion = gradleVersion,
                because = "The gradle version used is too old.",
                description = "The expected gradle version is 6.8.2.",
                solutions = listOf(Solution("Update the gradle-wrapper.properties with a newer version"))
            )
        }
    }

    private fun configureProjectVersionAndGroupId(project: Project) {
        var version = project.properties["version"] ?: DEFAULT_VERSION

        if (version == "unspecified") {
            version = DEFAULT_VERSION
        }

        project.version = version
        project.group = "com.github.minigdx"
    }

    private fun configurePublication(project: Project) {
        project.apply { it.plugin("maven-publish") }
        project.afterEvaluate {
            val ext = project.extensions.getByType(MiniGdxDeveloperExtension::class.java)
            project.extensions.configure(PublishingExtension::class.java) {
                // Configure publication (what to publish)
                it.publications.withType(MavenPublication::class.java).configureEach {
                    it.pom {
                        it.name.set(ext.name)
                        it.description.set(ext.description)
                        it.licenses {
                            it.license {
                                it.name.set(ext.licence.name)
                                it.url.set(ext.licence.url)
                            }
                        }
                        it.url.set(ext.projectUrl)
                        it.issueManagement {
                            it.system.set("Github")
                            it.url.set(ext.projectUrl.map { url -> "$url/issues" })
                        }
                        it.scm {
                            it.connection.set(ext.projectUrl.map { url -> "$url/.git" })
                            it.url.set(ext.projectUrl)
                        }
                        it.developers { spec ->
                            ext.developers.forEach { dev ->
                                spec.developer {
                                    it.name.set(dev.name)
                                    it.email.set(dev.email)
                                    it.url.set(dev.url)
                                }
                            }
                        }

                    }
                }
            }
        }
    }

    private fun configureDokka(project: Project) {
        if (project.extraProperties.has(MiniGdxDeveloperExtension.DOKKA_SKIP_PROPERTY)) {
            return
        }
        // TODO - [CACHE] Dokka doesn't support Configuration Cache yet
        //      See: https://github.com/Kotlin/dokka/issues/2231
        project.extensions.extraProperties.set(
            "org.jetbrains.dokka.experimental.gradle.pluginMode",
            "V2EnabledWithHelpers"
        )
        project.apply { it.plugin("org.jetbrains.dokka") }
    }

    private fun configureProjectRepository(project: Project) {
        project.repositories.mavenCentral()
        project.repositories.google()
        project.repositories.mavenLocal()
    }

    private fun configureLinter(project: Project) {
        if (project.findProperty(MiniGdxDeveloperExtension.KTLINT_PROPERTY) != "false") {
            project.apply { it.plugin("org.jlleitschuh.gradle.ktlint") }
        }
    }

    private fun copy(projectName: String, gradleVersion: String, filename: String, target: File) {
        val content = classLoader.getResourceAsStream(filename) ?: throw MiniGdxException.create(
            severity = Severity.GRAVE,
            projectName = projectName,
            gradleVersion = gradleVersion,
            because = "'$filename' file not found in the plugin jar! The plugin might have been incorrectly packaged.",
            description = "The plugin is trying to copy a resource that should has been packaged into the plugin " +
                    "but is not. As this file is required, the plugin will stop.",
            solutions = listOf(Solution("An issue can be reported to the developer", ISSUES))
        )
        target.resolve(File(filename).name).apply {
            if (!exists()) createNewFile()
            writeBytes(content.readBytes())
        }
    }

    private fun configureGithubWorkflow(project: Project) {
        // The task is already registered
        if (project.rootProject.tasks.findByName("createGithubWorkflows") != null) {
            return
        }
        val target = project.rootProject.projectDir.resolve(".github/workflows")
        val projectName = project.name
        val gradleVersion = project.gradle.gradleVersion

        project.rootProject.tasks.register("createGithubWorkflows") {
            it.group = "minigdx-dev"
            it.description = "Copy default Github workflows inside this project."
            it.doLast {
                if (!target.exists()) {
                    it.project.mkdir(".github/workflows")
                }
                copy(projectName, gradleVersion, "github/workflows/build.yml", target)
                copy(projectName, gradleVersion, "github/workflows/publish-release.yml", target)
            }
        }
    }

    private fun configureMakefile(project: Project) {
        // The task is already registered
        if (project.rootProject.tasks.findByName("createMakefile") != null) {
            return
        }
        val target = project.rootProject.projectDir
        val projectName = project.name
        val gradleVersion = project.gradle.gradleVersion

        project.rootProject.tasks.register("createMakefile") {
            it.group = "minigdx-dev"
            it.description = "Copy default Makefile inside this project."
            it.doLast {
                copy(projectName, gradleVersion, "Makefile", target)
            }
        }
    }

    private fun configureSonatype(project: Project) {
        project.apply { it.plugin("org.danilopianini.publish-on-central") }
        project.afterEvaluate {
            val ext = project.extensions.getByType(MiniGdxDeveloperExtension::class.java)
            val publishOnCentral = project.extensions.getByType(PublishOnCentralExtension::class.java)

            publishOnCentral.projectDescription.set(ext.description)
            publishOnCentral.projectUrl.set(ext.projectUrl)
            publishOnCentral.scmConnection.set(ext.projectUrl.map { url -> "$url/.git" })

            val publications = project.extensions.getByType(PublishingExtension::class.java).publications

            // Add signing extension only if the signing data is available.
            if (project.properties["signing.base64.secretKey"] != null) {
                project.extensions.configure(SigningExtension::class.java) {
                    it.sign(publications)
                    it.useInMemoryPgpKeys(
                        project.properties["signing.base64.secretKey"].toString(),
                        project.properties["signing.password"].toString()
                    )
                }
            }

            project.tasks.withType(ZipMavenCentralPortalPublication::class.java) {
                // Adjust the version as the task is created BEFORE the version is computed
                // from the minigdx gradle plugin.
                it.archiveVersion.set(project.version.toString())
            }

            // Disable the release task for modules without artifacts (root project, for example)
            project.tasks.named(RELEASE_TASK_NAME).configure {
                it.onlyIf { project.layout.buildDirectory.dir("maven-central-portal").get().asFile.exists() }
            }

            project.tasks.withType(Sign::class.java) {
                it.onlyIf { project.properties["signing.base64.secretKey"] != null }
            }
        }
    }

    companion object {

        private const val DEFAULT_VERSION = "DEV-SNAPSHOT"
    }
}
